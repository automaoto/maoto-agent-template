name: Deploy

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set BUILD_NUMBER and GIT_COMMIT
        run: |
          echo "BUILD_NUMBER=${{ github.run_number }}" >> $GITHUB_ENV
          echo "GIT_COMMIT=${{ github.sha }}" >> $GITHUB_ENV

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build Docker Images and Push to Registry
        env:
          DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
          BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          GIT_COMMIT: ${{ env.GIT_COMMIT }}
        run: |
          TARGET_DIR=./src/apiinterfaces/maoto-agent
          mkdir -p "$TARGET_DIR"
          
          PROJECT_DIR="./src"
          for DOCKERFILE in $(find $PROJECT_DIR -type f -name Dockerfile); do
            echo "Building image for $DOCKERFILE..."
            DIR=$(dirname $DOCKERFILE)
            IMAGE_NAME=$(basename $DIR)
            IMAGE_TAG="$BUILD_NUMBER-$GIT_COMMIT"
            BETA_MAOTO_PACKAGE=true
            docker build --build-arg USE_BETA_PACKAGE_VERSION=$BETA_MAOTO_PACKAGE -t "$DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" $DIR

            echo "Pushing image $IMAGE_NAME to Docker Hub..."
            docker push "$DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
          done

      - name: Login to AWS and Deploy to EKS
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-southeast-1
          DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
          BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          GIT_COMMIT: ${{ env.GIT_COMMIT }}
        run: |
          export AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_DEFAULT_REGION
          aws eks --region $AWS_DEFAULT_REGION update-kubeconfig --name kubernetes-server-aws
          if kubectl get secret registry-secret; then
            echo "Secret registry-secret already exists. Skipping creation."
          else
            echo "Creating secret registry-secret."
            kubectl create secret docker-registry registry-secret \
              --docker-server=docker.io \
              --docker-username=${{ secrets.DOCKER_USERNAME }} \
              --docker-password=${{ secrets.DOCKER_PASSWORD }} \
              --docker-email=${{ secrets.DOCKER_EMAIL }}
          fi
          IMAGE_TAG="$BUILD_NUMBER-$GIT_COMMIT"

          APIINTERFACES_ACTIVATE=true
          APIINTERFACES_LOADBALANCER=true
          DATABASEREDIS_ACTIVATE=true
          DATABASEPOSTGRES_ACTIVATE=true

          # Ensure the namespace exists
          REPO_NAME=$(basename ${{ github.repository }})
          NAMESPACE="$REPO_NAME-namespace"
          kubectl get namespace $NAMESPACE || kubectl create namespace $NAMESPACE

            helm upgrade --install kubernetes-server ./kubernetes \
              --set global.dockerRegistry="$DOCKER_REGISTRY/" \
              --set pullPolicy=Always \
              --namespace "$NAMESPACE" \
              --set image.tag="$IMAGE_TAG" \
              --set apiinterfaces.activate=$APIINTERFACES_ACTIVATE \
              --set apiinterfaces.loadbalancer=$APIINTERFACES_LOADBALANCER \
              --set redis.activate=$DATABASEREDIS_ACTIVATE \
              --set postgresql.activate=$DATABASEPOSTGRES_ACTIVATE

            # Restart all deployments (to ensure the db is reset)
            kubectl get deployments  -n "$NAMESPACE" -o name | xargs -n1 kubectl rollout restart -n "$NAMESPACE"
