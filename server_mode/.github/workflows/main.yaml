name: Deploy

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set BUILD_NUMBER and GIT_COMMIT
        run: |
          echo "BUILD_NUMBER=${{ github.run_number }}" >> $GITHUB_ENV
          echo "GIT_COMMIT=${{ github.sha }}" >> $GITHUB_ENV

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build Docker Images and Push to Registry
        env:
          DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
          BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          GIT_COMMIT: ${{ env.GIT_COMMIT }}
        run: |
          TARGET_DIR=./src/apiinterfaces/maoto-agent
          mkdir -p "$TARGET_DIR"
          
          PROJECT_DIR="./src"
          for DOCKERFILE in $(find $PROJECT_DIR -type f -name Dockerfile); do
            echo "Building image for $DOCKERFILE..."
            DIR=$(dirname $DOCKERFILE)
            IMAGE_NAME=$(basename $DIR)
            IMAGE_TAG="$BUILD_NUMBER-$GIT_COMMIT"
            BETA_MAOTO_PACKAGE=true
            docker build --build-arg USE_BETA_PACKAGE_VERSION=$BETA_MAOTO_PACKAGE -t "$DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" $DIR

            echo "Pushing image $IMAGE_NAME to Docker Hub..."
            docker push "$DOCKER_REGISTRY/$IMAGE_NAME:$IMAGE_TAG"
          done

      - name: Login to AWS and Deploy to EKS
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ap-southeast-1
          DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
          BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          GIT_COMMIT: ${{ env.GIT_COMMIT }}
        run: |

          # download kubernetes template from template repo
          REPO_NAME="maoto-agent-template"
          REPO_URL="https://github.com/automaoto/$REPO_NAME"
          git clone --depth 1 --filter=blob:none --no-checkout "$REPO_URL" temp-repo
          cd temp-repo
          git sparse-checkout init --cone
          git sparse-checkout set server_mode/kubernetes
          git checkout
          mv server_mode/kubernetes ../kubernetes
          cd ..
          rm -rf temp-repo

          # Set up kubectl
          export AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_DEFAULT_REGION
          aws eks --region $AWS_DEFAULT_REGION update-kubeconfig --name kubernetes-server-aws
          if kubectl get secret registry-secret; then
            echo "Secret registry-secret already exists. Skipping creation."
          else
            echo "Creating secret registry-secret."
            kubectl create secret docker-registry registry-secret \
              --docker-server=docker.io \
              --docker-username=${{ secrets.DOCKER_USERNAME }} \
              --docker-password=${{ secrets.DOCKER_PASSWORD }} \
              --docker-email=${{ secrets.DOCKER_EMAIL }}
          fi
          IMAGE_TAG="$BUILD_NUMBER-$GIT_COMMIT"

          # Ensure the namespace exists
          REPO_NAME=$(basename ${{ github.repository }})
          NAMESPACE="$REPO_NAME-namespace"
          kubectl get namespace $NAMESPACE || kubectl create namespace $NAMESPACE

          # Get env and secrets files
          echo "${{ env.ENV_SERVER_CONTENT }}" > .env_server
          echo "${{ secrets.SECRETS_SERVER_CONTENT }}" > .secrets_server

          # “source” the file so each KEY=VALUE line sets an environment variable
          set -a              # Enable 'export' of all variables loaded
          . ./.env_server     # Source the .env_server file (dot + filename)
          set +a              # Disable 'export all' mode
          
          # Only add each key=value pair if the environment variable is set (non-empty).
          HELM_SET_ARGS=()
          [ -n "${APIINTERFACES_ACTIVATE:-}" ] && HELM_SET_ARGS+=("apiinterfaces.activate=${APIINTERFACES_ACTIVATE}")
          [ -n "${APIINTERFACES_LOADBALANCER:-}" ] && HELM_SET_ARGS+=("apiinterfaces.loadbalancer=${APIINTERFACES_LOADBALANCER}")
          [ -n "${DATABASEREDIS_ACTIVATE:-}" ] && HELM_SET_ARGS+=("redis.activate=${DATABASEREDIS_ACTIVATE}")
          [ -n "${DATABASEPOSTGRES_ACTIVATE:-}" ] && HELM_SET_ARGS+=("postgresql.activate=${DATABASEPOSTGRES_ACTIVATE}")
          HELM_SET_STRING=$(IFS=, ; echo "${HELM_SET_ARGS[*]}")

          # Create or update configmap for non-sensitive environment variables
          kubectl create configmap my-env-config \
            --from-env-file=.env_server \
            --dry-run=client -o yaml | kubectl apply -f -
          # Create or update secret for sensitive environment variables
          kubectl create secret generic my-env-secrets \
            --from-env-file=.secrets_server \
            --dry-run=client -o yaml | kubectl apply -f -

          helm upgrade --install kubernetes-server ./kubernetes \
            --set global.dockerRegistry="$DOCKER_REGISTRY/" \
            --set pullPolicy=Always \
            --namespace "$NAMESPACE" \
            --set image.tag="$IMAGE_TAG" \
            --set $HELM_SET_STRING

          # Restart all deployments (to ensure the db is reset)
          kubectl get deployments  -n "$NAMESPACE" -o name | xargs -n1 kubectl rollout restart -n "$NAMESPACE"
